专用开发文档：Minecraft 玩家行为统计数据插件

> **项目名称**：`PlayerStatsLogger`
> **目标平台**：Paper 1.21.1（Bukkit API）
> **用途说明**：通过监听玩家行为，使用 Redis 实时缓存数据，并定期落盘至 MySQL
> **核心功能**：
> - 统计每个玩家：挖掘方块数、放置方块数、击杀敌对生物数
> - 所有变更先写入 **Redis**
> - 异步批量同步至 **MySQL**
> - 支持多服部署与高并发场景

---

## ✅ 一、总体架构图（AI 理解用）

```text
[玩家] 
   ↓ (行为)
[Spigot 事件] → 修改 Redis Hash 值（INCR）
                   ↓
       [定时任务 | 玩家离线] → 触发 saveToMySQL()
                                   ↓
                          [MySQL: player_statistics 表]
```

- ✅ **性能优化**：高频操作在内存（Redis），低频持久化到磁盘（MySQL）
- ✅ **可扩展性**：未来可加 UUID、维度拆分、排行榜广播等
- ✅ **健壮性**：断电后从 MySQL 重新加载，Redis 故障降级处理留空（可选）

---

## 🧱 二、最终输出文件清单

| 文件名 | 类型 | 作用 |
|--------|------|------|
| `PlayerStatsPlugin.java` | Java 主类 | 插件入口，管理生命周期 |
| `config.yml` | YAML 配置 | 数据库和 Redis 连接信息 |
| `pom.xml` | Maven 构建文件 | 依赖管理与打包 |
| `database_init.sql` | SQL 脚本 | 创建数据表 |
| （无额外类） | —— | 使用 Jedis 直连 Redis，无需封装实体 |

---

## 🗃️ 三、数据库设计（MySQL）

### 表名：`player_statistics`

| 字段名 | 类型 | 约束 | 含义 |
|--------|------|------|------|
| `player_name` | VARCHAR(16) | NOT NULL, UNIQUE | 玩家名称（暂用名字，建议未来升级为 UUID） |
| `blocks_broken` | INT | DEFAULT 0 | 挖掘总数 |
| `blocks_placed` | INT | DEFAULT 0 | 放置总数 |
| `mobs_killed` | INT | DEFAULT 0 | 击杀敌对生物总数 |
| `last_seen` | TIMESTAMP | DEFAULT NOW ON UPDATE | 最后活跃时间 |

### 建表语句（`database_init.sql`）
```sql
CREATE TABLE IF NOT EXISTS player_statistics (
    player_name VARCHAR(16) PRIMARY KEY,
    blocks_broken INT NOT NULL DEFAULT 0,
    blocks_placed INT NOT NULL DEFAULT 0,
    mobs_killed INT NOT NULL DEFAULT 0,
    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

---

## ⚡ 四、缓存设计（Redis）

### 使用数据结构：**Hash**

#### Redis Key 格式：
```
player_stats:<player_name>
```

#### Fields:
- `"blocks_broken"` → 数值（字符串整数）
- `"blocks_placed"` → 数值
- `"mobs_killed"` → 数值

#### 示例操作：
```bash
HINCRBY player_stats:Steve blocks_broken 1
HGETALL player_stats:Alice
```

> ✅ 原子操作保障并发安全
> ✅ 多服务器共享状态
> ✅ 断电丢失风险？→ 定时落库降低影响

---

## 🔌 五、配置文件（`config.yml`）

路径：`plugins/PlayerStatsLogger/config.yml`

```yaml
# MySQL 数据库配置
database:
  host: "localhost"
  port: 3306
  name: "minecraft_stats"
  username: "mc_stats"
  password: "secure_password_123"
  use_ssl: false
  auto_reconnect: true

# Redis 缓存配置
redis:
  host: "localhost"
  port: 6379
  password: ""        # 若未设置密码，请留空或删除字段
  database: 0         # Redis 默认 db 0
  timeout_ms: 2000    # 连接超时时间

# 插件运行参数
debug: false
auto_save_interval_minutes: 2   # 自动将 Redis 数据同步到 MySQL 的间隔
```

> ✅ 所有连接参数必须从该文件读取

---

## 🔧 六、主插件类定义（`PlayerStatsPlugin.java`）

### 类声明
```java
public class PlayerStatsPlugin extends JavaPlugin {
    private HikariDataSource mysqlPool;
    private JedisPool redisPool;
    private final Set<String> dirtyPlayers = ConcurrentHashMap.newKeySet(); // 需要保存的玩家名单
}
```

---

### 生命周期方法要求

#### `onEnable()`
1. 保存引用：`instance = this`
2. 保存默认配置文件（若不存在）
3. 加载 `config.yml`
4. 初始化 **MySQL HikariCP 连接池**
5. 初始化 **JedisPool（Redis 客户端）**
6. 创建 MySQL 数据表（执行一次）
7. 注册以下事件监听器：
    - `BlockBreakEvent`
    - `BlockPlaceEvent`
    - `EntityDeathEvent`
    - `PlayerQuitEvent`
8. 启动后台定时任务：每 N 分钟调用 `flushDirtyData()` 同步脏数据

#### `onDisable()`
1. 调用 `flushAllToMySQL()` 确保所有未保存数据落盘
2. 关闭 `redisPool` 和 `mysqlPool`

---

## 📡 七、事件监听逻辑（全部异步或原子更新）

### 1. 方块破坏：`BlockBreakEvent`
```java
@EventHandler
public void onBreak(BlockBreakEvent e) {
    Player p = e.getPlayer();
    updateRedis(p.getName(), "blocks_broken", 1);
}
```

### 2. 方块放置：`BlockPlaceEvent`
```java
@EventHandler
public void onPlace(BlockPlaceEvent e) {
    Player p = e.getPlayer();
    updateRedis(p.getName(), "blocks_placed", 1);
}
```

### 3. 生物死亡且由玩家击杀：`EntityDeathEvent`
```java
@EventHandler
public void onKill(EntityDeathEvent e) {
    Player killer = e.getEntity().getKiller();
    if (killer == null) return;
    if (!isHostileMob(e.getEntity())) return;

    updateRedis(killer.getName(), "mobs_killed", 1);
}

private boolean isHostileMob(Entity entity) {
    return entity instanceof Monster || 
           entity.getType() == EntityType.WITHER || 
           entity.getType() == EntityType.ENDERMAN ||
           entity.getType() == EntityType.RAVAGER;
}
```

### 工具方法：`updateRedis(...)`

```java
private void updateRedis(String playerName, String field, int delta) {
    try (Jedis jedis = redisPool.getResource()) {
        jedis.hincrBy("player_stats:" + playerName, field, delta);
        dirtyPlayers.add(playerName); // 标记为待同步
    } catch (Exception ex) {
        if (getConfig().getBoolean("debug")) {
            getLogger().warning("Redis error for " + playerName + ": " + ex.getMessage());
        }
    }
}
```

---

## 💾 八、持久化逻辑：从 Redis 写回 MySQL

### 方法签名
```java
public void savePlayerToMySQL(String playerName)
```

#### 功能描述：
1. 从 Redis 获取 `player_stats:<name>` 的三个字段值
2. 使用 **预编译语句 UPSERT** 写入 MySQL
3. 成功后删除 Redis 中该玩家的所有字段（表示已提交）
4. 移除 `dirtyPlayers` 中的标记

#### SQL 语句（复用型）
```sql
INSERT INTO player_statistics (player_name, blocks_broken, blocks_placed, mobs_killed)
VALUES (?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
blocks_broken = blocks_broken + VALUES(blocks_broken),
blocks_placed = blocks_placed + VALUES(blocks_placed),
mobs_killed = mobs_killed + VALUES(mobs_killed)
```

---

### Java 实现框架：

```java
public void savePlayerToMySQL(String playerName) {
    Map<String, String> data;
    try (Jedis jedis = redisPool.getResource()) {
        data = jedis.hgetAll("player_stats:" + playerName);
    } catch (Exception e) {
        getLogger().severe("无法从 Redis 读取 " + playerName);
        return;
    }

    if (data.isEmpty()) {
        dirtyPlayers.remove(playerName);
        return;
    }

    try (Connection conn = mysqlPool.getConnection()) {
        PreparedStatement ps = conn.prepareStatement(
            "INSERT INTO player_statistics (player_name, blocks_broken, blocks_placed, mobs_killed) " +
            "VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE " +
            "blocks_broken = blocks_broken + VALUES(blocks_broken), " +
            "blocks_placed = blocks_placed + VALUES(blocks_placed), " +
            "mobs_killed = mobs_killed + VALUES(mobs_killed)"
        );

        ps.setString(1, playerName);
        ps.setInt(2, parseInt(data.get("blocks_broken")));
        ps.setInt(3, parseInt(data.get("blocks_placed")));
        ps.setInt(4, parseInt(data.get("mobs_killed")));
        ps.executeUpdate();

        // 清理 Redis 已保存数据
        try (Jedis jedis = redisPool.getResource()) {
            jedis.hdel("player_stats:" + playerName, "blocks_broken", "blocks_placed", "mobs_killed");
        }
        dirtyPlayers.remove(playerName);

    } catch (SQLException e) {
        getLogger().severe("数据库写入失败：" + e.getMessage());
    }
}

private int parseInt(String s) {
    return s == null || s.isEmpty() ? 0 : Integer.parseInt(s);
}
```

---

## 🔁 九、定时同步任务

```java
int minutes = getConfig().getInt("auto_save_interval_minutes", 2);
long ticks = minutes * 60 * 20L;  // 转换为 tick

Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {
    if (dirtyPlayers.isEmpty()) return;
    for (String playerName : new HashSet<>(dirtyPlayers)) {
        savePlayerToMySQL(playerName);
    }
}, ticks, ticks); // 初次延迟后重复执行
```

> 👉 在 `onEnable()` 中启动此任务

---

## 🚪 十、玩家退出事件（触发立即保存）

```java
@EventHandler
public void onQuit(PlayerQuitEvent e) {
    String name = e.getPlayer().getName();
    Bukkit.getScheduler().runTaskAsynchronously(this, () -> savePlayerToMySQL(name));
}
```

> ❗注意：不阻塞主线程

---

## 📦 十一、Maven 构建文件（`pom.xml`）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>PlayerStatsLogger</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Spigot API -->
        <dependency>
            <groupId>org.spigotmc</groupId>
            <artifactId>spigot-api</artifactId>
            <version>1.20.4-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>

        <!-- MySQL Driver -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.33</version>
        </dependency>

        <!-- Redis Client: Jedis -->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>5.1.0</version>
        </dependency>

        <!-- HikariCP 连接池 -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.0.1</version>
        </dependency>
    </dependencies>

    <build>
        <finalName>PlayerStatsLogger</finalName>
        <plugins>
            <!-- Shade Plugin: 打包所有依赖 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <relocations>
                                <relocation>
                                    <pattern>com.zaxxer.hikari</pattern>
                                    <shadedPattern>shaded.com.zaxxer.hikari</shadedPattern>
                                </relocation>
                                <relocation>
                                    <pattern>redis.clients</pattern>
                                    <shadedPattern>shaded.redis.clients</shadedPattern>
                                </relocation>
                            </relocations>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

    <repositories>
        <repository>
            <id>spigot-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>
    </repositories>
</project>
```

---

## 🧪 十二、异常与容错设计（供 AI 理解）

| 场景 | 处理方式 |
|------|---------|
| Redis 连接失败 | 记录日志，跳过本次更新（不影响游戏） |
| MySQL 写入失败 | 日志报警，保留 `dirtyPlayers` 标记重试 |
| 插件重启 | 从 MySQL 加载历史总数，Redis 中新增行为继续累加 |
| 玩家改名 | 不处理（基于 `player_name`），建议未来改用 UUID |

---

## 🔚 十三、总结关键词（便于 AI 记忆）

| 类别 | 关键词 |
|------|--------|
| 插件名 | `PlayerStatsLogger` |
| 主类 | `PlayerStatsPlugin extends JavaPlugin` |
| 缓存 | `Redis`, `Jedis`, `Hash`, `HINCRBY` |
| 持久化 | `MySQL`, `HikariCP`, `UPSERT`, `ON DUPLICATE KEY UPDATE` |
| 统计字段 | `blocks_broken`, `blocks_placed`, `mobs_killed` |
| Redis Key | `player_stats:<player_name>` |
| 同步机制 | `dirtyPlayers Set` + 定时任务 + 登出触发 |
| 安全 | 所有 DB/Redis 操作异步进行 |

---
