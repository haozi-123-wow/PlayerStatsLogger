# PlayerStatsLogger 插件开发流程

## 项目概述

本项目旨在根据《开发文档.md》的详细规范，开发一个名为 `PlayerStatsLogger` 的 Minecraft Paper 插件。该插件通过监听玩家行为，使用 Redis 进行实时数据缓存，并定期将数据持久化到 MySQL 数据库。

## 详细执行步骤与状态追踪

### 第一阶段：项目基础架构与配置文件搭建

1.  **创建 Maven 构建文件 (`pom.xml`)**
    *   **目的**：定义项目依赖和构建配置。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在项目根目录创建 `pom.xml`。
        *   添加 Spigot API, MySQL Connector/J, Jedis, HikariCP 依赖。
        *   配置 Maven Shade Plugin 进行依赖打包和重定位。
    *   **产出物**：`pom.xml`

2.  **创建 Spigot 插件描述文件 (`plugin.yml`)**
    *   **目的**：向 Spigot 服务器声明插件信息。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在 `src/main/resources/` 目录下创建 `plugin.yml`。
        *   填写 name, version, main, author, api-version。
    *   **产出物**：`src/main/resources/plugin.yml`

3.  **创建插件配置文件 (`config.yml`)**
    *   **目的**：提供数据库和 Redis 的连接参数。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在 `src/main/resources/` 目录下创建 `config.yml`。
        *   填写 database, redis, debug, auto_save_interval_minutes 等配置项。
    *   **产出物**：`src/main/resources/config.yml`

4.  **创建数据库初始化脚本 (`database_init.sql`)**
    *   **目的**：定义 MySQL 数据表结构。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在 `src/main/resources/` 目录下创建 `database_init.sql`。
        *   编写 `CREATE TABLE IF NOT EXISTS player_statistics (...)` 语句。
    *   **产出物**：`src/main/resources/database_init.sql`

### 第二阶段：核心插件类 (`PlayerStatsPlugin.java`) 开发

5.  **创建主类文件与基本结构**
    *   **目的**：建立插件的核心 Java 类。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在 `src/main/java/tj/playerStatsLogger/` 目录下创建 `PlayerStatsPlugin.java`。
        *   声明类 `public class PlayerStatsPlugin extends JavaPlugin`。
        *   声明成员变量 `mysqlPool`, `redisPool`, `dirtyPlayers`, `instance`。
    *   **产出物**：`src/main/java/tj/playerStatsLogger/PlayerStatsPlugin.java` (基本框架)

6.  **实现 `onEnable()` 方法**
    *   **目的**：插件启动时执行所有初始化操作。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   保存插件实例。
        *   加载配置文件。
        *   初始化 MySQL HikariCP 连接池。
        *   初始化 Redis JedisPool。
        *   创建数据表。
        *   注册事件监听器。
        *   启动定时同步任务。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onEnable()` 方法。

7.  **实现 `onDisable()` 方法**
    *   **目的**：插件关闭时执行清理操作。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   刷新所有数据到 MySQL。
        *   关闭 Redis 和 MySQL 连接池。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onDisable()` 方法。

### 第三阶段：事件监听与统计逻辑实现

8.  **实现 `updateRedis` 辅助方法**
    *   **目的**：封装对 Redis 的原子性更新操作。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `private void updateRedis(String playerName, String field, int delta)`。
        *   使用 `jedis.hincrBy()` 更新数据。
        *   将玩家加入 `dirtyPlayers` 集合。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `updateRedis` 方法。

9.  **实现方块破坏事件监听 (`BlockBreakEvent`)**
    *   **目的**：监听并记录方块破坏行为。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `@EventHandler public void onBreak(BlockBreakEvent e)`。
        *   调用 `updateRedis(p.getName(), "blocks_broken", 1)`。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onBreak` 方法。

10. **实现方块放置事件监听 (`BlockPlaceEvent`)**
    *   **目的**：监听并记录方块放置行为。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `@EventHandler public void onPlace(BlockPlaceEvent e)`。
        *   调用 `updateRedis(p.getName(), "blocks_placed", 1)`。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onPlace` 方法。

11. **实现生物击杀事件监听 (`EntityDeathEvent`)**
    *   **目的**：监听并记录所有生物击杀行为。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `@EventHandler public void onKill(EntityDeathEvent e)`。
        *   获取击杀者 `Player killer = e.getEntity().getKiller();`，如果 `killer` 为 `null` 则直接返回。
        *   **注意**：根据用户反馈，只要是被玩家击杀的生物都算，无需判断是否为敌对生物。
        *   调用 `updateRedis(killer.getName(), "mobs_killed", 1)`。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onKill` 方法。

12. **实现 `isHostileMob` 辅助方法 (已废弃)**
    *   **目的**：此方法已不再需要，因为所有生物击杀都计入统计。
    *   **状态**：`[x]` 已废弃
    *   **具体操作**：无。

### 第四阶段：数据持久化与同步逻辑实现

13. **实现 `parseInt` 辅助方法**
    *   **目的**：安全地将字符串转换为整数。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `private int parseInt(String s)`。
        *   处理 `null` 或空字符串情况。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `parseInt` 方法。

14. **实现 `savePlayerToMySQL` 方法**
    *   **目的**：将单个玩家的统计数据从 Redis 同步到 MySQL。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   从 Redis 读取数据。
        *   使用 `PreparedStatement` 和 `ON DUPLICATE KEY UPDATE` 写入 MySQL。
        *   成功后清理 Redis 数据和脏数据标记。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `savePlayerToMySQL` 方法。

### 第五阶段：玩家退出事件处理

15. **实现玩家退出事件监听 (`PlayerQuitEvent`)**
    *   **目的**：玩家离线时立即保存其数据。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   创建 `@EventHandler public void onQuit(PlayerQuitEvent e)`。
        *   异步调用 `savePlayerToMySQL(name)`。
    *   **产出物**：`PlayerStatsPlugin.java` 中的 `onQuit` 方法。

### 第六阶段：构建与最终产出

16. **执行 Maven 构建**
    *   **目的**：生成最终的 `.jar` 插件文件。
    *   **状态**：`[ ]` 未完成
    *   **具体操作**：
        *   在项目根目录执行 `mvn clean package`。
    *   **产出物**：`target/PlayerStatsLogger.jar`

## 最终交付物

*   **源代码**：完整的 `src` 目录。
*   **构建脚本**：`pom.xml` 文件。
*   **可部署插件**：`target/PlayerStatsLogger.jar` 文件。
